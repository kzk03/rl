"""Reviewer Invitation Acceptance Modeling (Action Space: Review or Not)

Simplified objective:
  For each invited reviewer (appearing under change['reviewers']['REVIEWER'])
  predict whether they will actually participate (leave at least one non-auto
  message) on that change. This constrains the action space to binary:
    - act (review)
    - skip

Output:
  Samples: {'state': {...features...}, 'label': 0/1}

Evaluation:
  Temporal split (by invitation time) -> train / test
  Metrics: accuracy, precision, recall, f1, auc, brier

Features (initial minimal set):
  - reviewer_recent_reviews_7d / 30d
  - reviewer_gap_days (days since last review prior to invitation)
  - reviewer_total_reviews
  - project_user_prev_reviews_30d (user reviews for this project last 30d)
  - project_user_share_30d (ratio project_user_prev_reviews_30d / reviewer_recent_reviews_30d)

Assumptions / Simplifications:
  * Invitation time approximated as change created time (no per-reviewer invite ts available).
  * Participation defined as authoring at least one message whose tag does not start with 'autogenerated:'
    and whose author account id matches the reviewer (service users filtered out by tag heuristics).
  * Large JSON is loaded fully; optimize later with streaming if needed.
"""
from __future__ import annotations

import json
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Tuple

import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import (
    accuracy_score,
    brier_score_loss,
    precision_recall_fscore_support,
    roc_auc_score,
)
from sklearn.preprocessing import StandardScaler


def _parse_dt(ts: str | None):
    from datetime import datetime, timezone
    if not ts:
        return None
    ts = ts.replace('T', ' ').replace('Z', '+00:00')
    try:
        dt = datetime.fromisoformat(ts)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc)
    except Exception:
        return None


def build_reviewer_invitation_samples(
    json_path: str | Path,
    min_reviews: int = 20,
) -> List[Dict[str, Any]]:
    path = Path(json_path)
    data = json.loads(path.read_text())

    # reviewer history timeline (list of (ts, project))
    reviewer_history: Dict[int, List[Tuple[Any, str]]] = defaultdict(list)
    samples: List[Dict[str, Any]] = []

    for ch in data:
        proj = ch.get('project') or 'unknown'
        created = _parse_dt(ch.get('created') or ch.get('updated') or ch.get('submitted'))
        if not created:
            continue
        reviewers_block = (ch.get('reviewers') or {}).get('REVIEWER') or []
        invited_ids = []
        for rv in reviewers_block:
            rid = rv.get('_account_id')
            if rid is not None:
                invited_ids.append(rid)
        # determine participation set
        participated: set[int] = set()
        for msg in ch.get('messages', []) or []:
            tag = (msg.get('tag') or '')
            if tag.startswith('autogenerated:'):
                continue
            author = msg.get('author') or {}
            aid = author.get('_account_id')
            if aid in invited_ids:
                participated.add(aid)
        # For each invitation create sample
        for rid in invited_ids:
            history = reviewer_history[rid]
            # compute features from past only
            past = [h for h in history if h[0] < created]
            from datetime import timedelta
            recent_7 = sum(1 for (ts, _) in past if (created - ts).days <= 7)
            recent_30 = sum(1 for (ts, _) in past if (created - ts).days <= 30)
            last_gap = 0
            if len(past) >= 1:
                last_gap = (created - past[-1][0]).days
            total_reviews = len(past)
            proj_prev_30 = sum(1 for (ts, p) in past if p == proj and (created - ts).days <= 30)
            proj_share = (proj_prev_30 / recent_30) if recent_30 > 0 else 0.0
            label = 1 if rid in participated else 0
            samples.append(
                {
                    'state': {
                        'reviewer_id': rid,
                        'recent_reviews_7d': recent_7,
                        'recent_reviews_30d': recent_30,
                        'reviewer_gap_days': last_gap,
                        'reviewer_total_reviews': total_reviews,
                        'project_user_prev_reviews_30d': proj_prev_30,
                        'project_user_share_30d': proj_share,
                    },
                    'label': label,
                    'ts': created.isoformat(),
                }
            )
        # update history with participation events (consider only actual participation for future features)
        for rid in participated:
            reviewer_history[rid].append((created, proj))

    # filter reviewers with insufficient history
    filtered = [s for s in samples if s['state']['reviewer_total_reviews'] >= min_reviews]
    return filtered


@dataclass
class ReviewerAcceptanceModelConfig:
    max_iter: int = 400
    l2: float = 1.0
    scale: bool = True


class ReviewerAcceptanceModel:
    def __init__(self, config: ReviewerAcceptanceModelConfig | None = None):
        self.config = config or ReviewerAcceptanceModelConfig()
        self.model: LogisticRegression | None = None
        self.scaler: StandardScaler | None = None
        self.features = [
            'recent_reviews_7d',
            'recent_reviews_30d',
            'reviewer_gap_days',
            'reviewer_total_reviews',
            'project_user_prev_reviews_30d',
            'project_user_share_30d',
        ]

    def _vec(self, state: Dict[str, Any]):
        import numpy as np
        return np.array([float(state.get(f, 0.0)) for f in self.features], dtype=float)

    def fit(self, samples: List[Dict[str, Any]]):
        import numpy as np
        X = np.vstack([self._vec(s['state']) for s in samples])
        y = np.array([s['label'] for s in samples])
        if self.config.scale:
            self.scaler = StandardScaler()
            X = self.scaler.fit_transform(X)
        self.model = LogisticRegression(max_iter=self.config.max_iter, C=1.0 / self.config.l2)
        self.model.fit(X, y)

    def predict_proba(self, states: List[Dict[str, Any]]):
        import numpy as np
        if self.model is None:
            raise RuntimeError('model not fit')
        X = np.vstack([self._vec(s) for s in states])
        if self.scaler is not None:
            X = self.scaler.transform(X)
        return self.model.predict_proba(X)[:, 1]


def temporal_train_test_split(samples: List[Dict[str, Any]], test_ratio: float = 0.2):
    samples_sorted = sorted(samples, key=lambda s: s['ts'])
    n_test = max(1, int(len(samples_sorted) * test_ratio))
    train = samples_sorted[:-n_test]
    test = samples_sorted[-n_test:]
    return train, test


def evaluate_acceptance_model(samples: List[Dict[str, Any]]):
    train, test = temporal_train_test_split(samples)
    model = ReviewerAcceptanceModel()
    model.fit(train)
    y_true = [s['label'] for s in test]
    y_prob = model.predict_proba([s['state'] for s in test])
    y_pred = [1 if p >= 0.5 else 0 for p in y_prob]
    acc = accuracy_score(y_true, y_pred)
    prec, rec, f1, _ = precision_recall_fscore_support(y_true, y_pred, average='binary', zero_division=0)
    try:
        auc = roc_auc_score(y_true, y_prob)
    except ValueError:
        auc = float('nan')
    brier = brier_score_loss(y_true, y_prob)
    pos_rate = sum(y_true) / len(y_true) if y_true else 0.0
    return {
        'n_train': len(train),
        'n_test': len(test),
        'accuracy': acc,
        'precision': prec,
        'recall': rec,
        'f1': f1,
        'auc': auc,
        'brier': brier,
        'positive_rate_test': pos_rate,
    }, model, test, y_prob


__all__ = [
    'build_reviewer_invitation_samples',
    'ReviewerAcceptanceModel',
    'evaluate_acceptance_model',
]
