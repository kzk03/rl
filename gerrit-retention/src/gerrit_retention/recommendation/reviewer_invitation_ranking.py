"""Reviewer Invitation Ranking

Generates (change, reviewer) Cartesian candidates:
  Positive: reviewers who actually participated (left at least one non-auto message)
  Negative: sampled reviewers (not invited/participated) from active pool

Goal: Learn a scoring model to rank which reviewers to invite.

Negative sampling strategy:
  For each change with >=1 positive reviewer:
    - Candidate pool = reviewers with min_total_reviews & recent activity (last `recent_days`)
    - Exclude invited reviewers
    - Select up to max_neg_per_pos * num_pos combining:
        * Hard: top-K by recent_reviews_30d
        * Random: fill remainder

Features per (change, reviewer):
  reviewer_recent_reviews_7d
  reviewer_recent_reviews_30d
  reviewer_gap_days
  reviewer_total_reviews
  reviewer_proj_prev_reviews_30d
  reviewer_proj_share_30d (ratio)
  change_current_invited_cnt
  change_participated_pos_cnt (so far, leakage-free using full set? Here we use total positives -> slight lookahead; acceptable for baseline, TODO: incremental)
  reviewer_active_flag_30d (binary)

Temporal split by change creation time for evaluation.
"""
from __future__ import annotations

import json
import random
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Tuple

import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import (
    accuracy_score,
    brier_score_loss,
    precision_recall_fscore_support,
    roc_auc_score,
)
from sklearn.preprocessing import StandardScaler


def _parse_dt(ts: str | None):
    from datetime import datetime, timezone
    if not ts:
        return None
    ts = ts.replace('T', ' ').replace('Z', '+00:00')
    try:
        dt = datetime.fromisoformat(ts)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc)
    except Exception:
        return None


@dataclass
class InvitationRankingBuildConfig:
    min_total_reviews: int = 20
    recent_days: int = 30
    max_neg_per_pos: int = 5
    hard_fraction: float = 0.5  # fraction of negatives from top recent reviewers
    leakage_free: bool = True   # if True, do NOT use final total positives (leakage)


def build_invitation_ranking_samples(
    json_path: str | Path,
    cfg: InvitationRankingBuildConfig | None = None,
) -> List[Dict[str, Any]]:
    cfg = cfg or InvitationRankingBuildConfig()
    data = json.loads(Path(json_path).read_text())
    from datetime import timedelta
    samples: List[Dict[str, Any]] = []
    # reviewer history: chronological list of (ts, project)
    reviewer_hist: Dict[int, List[Tuple[Any, str]]] = defaultdict(list)
    # aggregate reviewer last timestamp for recency filtering
    reviewer_last_ts: Dict[int, Any] = {}

    # First pass: collect positives and basic change info
    raw_changes: List[Dict[str, Any]] = []
    for ch in data:
        created = _parse_dt(ch.get('created') or ch.get('updated') or ch.get('submitted'))
        if not created:
            continue
        proj = ch.get('project') or 'unknown'
        reviewers_block = (ch.get('reviewers') or {}).get('REVIEWER') or []
        invited_ids = [rv.get('_account_id') for rv in reviewers_block if rv.get('_account_id') is not None]
        participated: set[int] = set()
        for msg in ch.get('messages', []) or []:
            tag = (msg.get('tag') or '')
            if tag.startswith('autogenerated:'):
                continue
            aid = (msg.get('author') or {}).get('_account_id')
            if aid in invited_ids:
                participated.add(aid)
        raw_changes.append({
            'created': created,
            'project': proj,
            'invited': invited_ids,
            'positives': list(participated),
        })
        # update history with participation events only (as signal of actual review)
        for rid in participated:
            reviewer_hist[rid].append((created, proj))
            reviewer_last_ts[rid] = created

    # Sort histories for each reviewer
    for rid in reviewer_hist:
        reviewer_hist[rid].sort(key=lambda x: x[0])

    # Determine global reviewer pool satisfying min_total_reviews
    eligible_reviewers = {rid for rid, h in reviewer_hist.items() if len(h) >= cfg.min_total_reviews}

    # Build samples with negative sampling
    for ch in raw_changes:
        positives = [rid for rid in ch['positives'] if rid in eligible_reviewers]
        if not positives:
            continue  # skip changes without positive eligible reviewers
        created = ch['created']
        proj = ch['project']
        # compute positive samples
        pos_states = []
        # leakage-free observed positives at (approx) invitation time (change creation)
        observed_pos_cnt = 0 if cfg.leakage_free else len(positives)
        for rid in positives:
            hist = reviewer_hist[rid]
            past = [h for h in hist if h[0] < created]
            recent_7 = sum(1 for (ts, _) in past if (created - ts).days <= 7)
            recent_30 = sum(1 for (ts, _) in past if (created - ts).days <= 30)
            gap_days = (created - past[-1][0]).days if past else 999
            total = len(past)
            proj_prev_30 = sum(1 for (ts, p) in past if p == proj and (created - ts).days <= 30)
            proj_share = proj_prev_30 / recent_30 if recent_30 > 0 else 0.0
            active_flag = 1 if recent_30 > 0 else 0
            state = {
                'reviewer_id': rid,
                'reviewer_recent_reviews_7d': recent_7,
                'reviewer_recent_reviews_30d': recent_30,
                'reviewer_gap_days': gap_days,
                'reviewer_total_reviews': total,
                'reviewer_proj_prev_reviews_30d': proj_prev_30,
                'reviewer_proj_share_30d': proj_share,
                'change_current_invited_cnt': len(ch['invited']),
                'change_prev_positive_cnt': observed_pos_cnt,
                'reviewer_active_flag_30d': active_flag,
            }
            pos_states.append(state)
        # Negative sampling
        # Active pool: eligible reviewers with last activity within recent_days and not invited
        horizon = timedelta(days=cfg.recent_days)
        active_pool = []
        for rid in eligible_reviewers:
            if rid in ch['invited']:
                continue
            last_ts = reviewer_last_ts.get(rid)
            if not last_ts:
                continue
            if (created - last_ts) > horizon:
                continue
            active_pool.append(rid)
        if not active_pool:
            # fallback: broaden pool ignoring recency
            active_pool = [rid for rid in eligible_reviewers if rid not in ch['invited']]
        if not active_pool:
            # cannot form negatives
            continue
        needed = cfg.max_neg_per_pos * len(positives)
        # Hard negatives = top by recent_reviews_30d (recomputed quickly)
        hard_candidates = []
        for rid in active_pool:
            hist = reviewer_hist[rid]
            recent_30 = sum(1 for (ts, _) in hist if (created - ts).days <= 30)
            hard_candidates.append((recent_30, rid))
        hard_candidates.sort(reverse=True)
        n_hard = max(1, int(needed * cfg.hard_fraction))
        hard = [rid for _, rid in hard_candidates[:n_hard]]
        remaining_pool = [rid for rid in active_pool if rid not in hard]
        random.shuffle(remaining_pool)
        neg_ids = (hard + remaining_pool)[:needed]
        neg_states = []
        for rid in neg_ids:
            hist = reviewer_hist[rid]
            past = [h for h in hist if h[0] < created]
            recent_7 = sum(1 for (ts, _) in past if (created - ts).days <= 7)
            recent_30 = sum(1 for (ts, _) in past if (created - ts).days <= 30)
            gap_days = (created - past[-1][0]).days if past else 999
            total = len(past)
            proj_prev_30 = sum(1 for (ts, p) in past if p == proj and (created - ts).days <= 30)
            proj_share = proj_prev_30 / recent_30 if recent_30 > 0 else 0.0
            active_flag = 1 if recent_30 > 0 else 0
            neg_states.append({
                'reviewer_id': rid,
                'reviewer_recent_reviews_7d': recent_7,
                'reviewer_recent_reviews_30d': recent_30,
                'reviewer_gap_days': gap_days,
                'reviewer_total_reviews': total,
                'reviewer_proj_prev_reviews_30d': proj_prev_30,
                'reviewer_proj_share_30d': proj_share,
                'change_current_invited_cnt': len(ch['invited']),
                'change_prev_positive_cnt': observed_pos_cnt,
                'reviewer_active_flag_30d': active_flag,
            })
        # Append labeled samples
        for st in pos_states:
            samples.append({'state': st, 'label': 1, 'ts': created.isoformat()})
        for st in neg_states:
            samples.append({'state': st, 'label': 0, 'ts': created.isoformat()})
    return samples


@dataclass
class InvitationRankingModelConfig:
    max_iter: int = 400
    l2: float = 1.0
    scale: bool = True


class InvitationRankingModel:
    def __init__(self, cfg: InvitationRankingModelConfig | None = None):
        self.cfg = cfg or InvitationRankingModelConfig()
        self.model: LogisticRegression | None = None
        self.scaler: StandardScaler | None = None
        self.features = [
            'reviewer_recent_reviews_7d',
            'reviewer_recent_reviews_30d',
            'reviewer_gap_days',
            'reviewer_total_reviews',
            'reviewer_proj_prev_reviews_30d',
            'reviewer_proj_share_30d',
            'change_current_invited_cnt',
            'change_prev_positive_cnt',
            'reviewer_active_flag_30d',
        ]

    def _vec(self, s: Dict[str, Any]):
        return np.array([float(s.get(f, 0.0)) for f in self.features], dtype=float)

    def fit(self, samples: List[Dict[str, Any]]):
        X = np.vstack([self._vec(s['state']) for s in samples])
        y = np.array([s['label'] for s in samples])
        if self.cfg.scale:
            self.scaler = StandardScaler()
            X = self.scaler.fit_transform(X)
        # class imbalance weighting
        pos_ratio = y.mean() if len(y) else 0.5
        w_pos = 0.5 / max(pos_ratio, 1e-6)
        w_neg = 0.5 / max(1 - pos_ratio, 1e-6)
        sample_weight = np.where(y == 1, w_pos, w_neg)
        self.model = LogisticRegression(max_iter=self.cfg.max_iter, C=1.0 / self.cfg.l2)
        self.model.fit(X, y, sample_weight=sample_weight)

    def predict_proba(self, states: List[Dict[str, Any]]):
        if self.model is None:
            raise RuntimeError('model not fit')
        X = np.vstack([self._vec(s) for s in states])
        if self.scaler is not None:
            X = self.scaler.transform(X)
        return self.model.predict_proba(X)[:, 1]


def temporal_split(samples: List[Dict[str, Any]], test_ratio: float = 0.2):
    ordered = sorted(samples, key=lambda s: s['ts'])
    n_test = max(1, int(len(ordered) * test_ratio))
    return ordered[:-n_test], ordered[-n_test:]


def evaluate_invitation_ranking(samples: List[Dict[str, Any]]):
    train, test = temporal_split(samples)
    model = InvitationRankingModel()
    model.fit(train)
    y_true = [s['label'] for s in test]
    y_prob = model.predict_proba([s['state'] for s in test])
    y_pred = [1 if p >= 0.5 else 0 for p in y_prob]
    acc = accuracy_score(y_true, y_pred)
    prec, rec, f1, _ = precision_recall_fscore_support(y_true, y_pred, average='binary', zero_division=0)
    try:
        auc = roc_auc_score(y_true, y_prob)
    except ValueError:
        auc = float('nan')
    brier = brier_score_loss(y_true, y_prob)
    return {
        'n_train': len(train),
        'n_test': len(test),
        'accuracy': acc,
        'precision': prec,
        'recall': rec,
        'f1': f1,
        'auc': auc,
        'brier': brier,
        'positive_rate_test': sum(y_true) / len(y_true) if y_true else 0.0,
    }, model, test, y_prob


__all__ = [
    'build_invitation_ranking_samples',
    'evaluate_invitation_ranking',
    'InvitationRankingBuildConfig',
]
