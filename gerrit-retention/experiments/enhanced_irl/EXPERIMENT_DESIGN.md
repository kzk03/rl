# Enhanced IRL 実験設計書

## 実験概要

**目的**: Random Forest ベースラインを超えるレビュワー継続予測モデルの開発

**アプローチ**: 時系列特徴量 + Attention 機構付き LSTM による IRL 拡張

---

## 1. 予測タスク定義

### タスク

指定された将来期間内に、レビュワーがレビューリクエストを受け入れる（accept）かどうかを予測

### ラベル定義

```
label = 1: 将来期間内にaccept（label=1）が1回以上存在
label = 0: 将来期間内にacceptが存在しない、またはデータがない
```

---

## 2. 時間軸の設計

### 固定期間

- **観測期間（全体）**: 2021-01-01 〜 2024-01-01（3 年間）
- **学習用観測期間**: 2021-01-01 〜 2023-01-01（2 年間）
- **評価用観測期間**: 2023-01-01 〜 2024-01-01（1 年間）

### 予測期間（可変）

観測期間終了後の将来期間を 4 パターン設定：

| 期間 ID | 開始月   | 終了月    | 期間長 | 説明         |
| ------- | -------- | --------- | ------ | ------------ |
| 0-3m    | 0 ヶ月後 | 3 ヶ月後  | 3 ヶ月 | 直近の将来   |
| 3-6m    | 3 ヶ月後 | 6 ヶ月後  | 3 ヶ月 | 中期の将来   |
| 6-9m    | 6 ヶ月後 | 9 ヶ月後  | 3 ヶ月 | やや遠い将来 |
| 9-12m   | 9 ヶ月後 | 12 ヶ月後 | 3 ヶ月 | 遠い将来     |

### 期間組み合わせ（クロス評価）

**制約条件**: 時系列順序を保つため、Eval 予測期間 >= Train 予測期間

有効な組み合わせ（10 通り）:

| #   | Train 予測期間 | Eval 予測期間 | 説明                    |
| --- | -------------- | ------------- | ----------------------- |
| 1   | 0-3m           | 0-3m          | 同一期間                |
| 2   | 0-3m           | 3-6m          | Train 短期 →Eval 中期   |
| 3   | 0-3m           | 6-9m          | Train 短期 →Eval 長期   |
| 4   | 0-3m           | 9-12m         | Train 短期 →Eval 最長期 |
| 5   | 3-6m           | 3-6m          | 同一期間                |
| 6   | 3-6m           | 6-9m          | Train 中期 →Eval 長期   |
| 7   | 3-6m           | 9-12m         | Train 中期 →Eval 最長期 |
| 8   | 6-9m           | 6-9m          | 同一期間                |
| 9   | 6-9m           | 9-12m         | Train 長期 →Eval 最長期 |
| 10  | 9-12m          | 9-12m         | 同一期間                |

---

## 3. ラベル計算の詳細

### ⚠️ 重要な修正点

**以前のバグ**: Train/Eval 両方で同じ予測期間を使用していた

```python
# ❌ 間違い
all_data[key] = prepare_data(df, ..., eval_s, eval_e)  # Trainも同じ期間
```

**修正後**: Train/Eval で個別に予測期間を指定

```python
# ✅ 正しい
all_data[key] = prepare_data(
    df, train_start, train_end, eval_start, eval_end,
    train_s, train_e,  # Train用の予測期間
    eval_s, eval_e     # Eval用の予測期間
)
```

### 具体例

#### ケース 1: Train=0-3m, Eval=3-6m

**Train データ**:

- 観測期間: 2021-01-01 〜 2023-01-01
- 予測期間: 2023-01-01 〜 2023-04-01（0-3 ヶ月後）
- レビュワー A の観測履歴: 〜2023-01-01
- レビュワー A のラベル: 2023-01-01〜2023-04-01 内に accept があれば 1

**Eval データ**:

- 観測期間: 2023-01-01 〜 2024-01-01
- 予測期間: 2024-04-01 〜 2024-07-01（3-6 ヶ月後）
- レビュワー B の観測履歴: 〜2024-01-01
- レビュワー B のラベル: 2024-04-01〜2024-07-01 内に accept があれば 1

#### ケース 2: Train=3-6m, Eval=3-6m（同一期間）

**Train データ**:

- 観測期間: 2021-01-01 〜 2023-01-01
- 予測期間: 2023-04-01 〜 2023-07-01（3-6 ヶ月後）
- レビュワー A のラベル: 2023-04-01〜2023-07-01 内に accept があれば 1

**Eval データ**:

- 観測期間: 2023-01-01 〜 2024-01-01
- 予測期間: 2024-04-01 〜 2024-07-01（3-6 ヶ月後）
- レビュワー B のラベル: 2024-04-01〜2024-07-01 内に accept があれば 1

---

## 4. 特徴量設計

### 4.1 状態特徴量（10 次元）- IRL 互換

オリジナル IRL と同一の特徴量を使用（比較の公平性のため）:

| #   | 特徴量名                  | 計算方法                           | 正規化範囲          |
| --- | ------------------------- | ---------------------------------- | ------------------- |
| 1   | experience_days           | 初出現から観測終了までの日数 / 730 | [0, ∞)              |
| 2   | total_changes             | 総レビュー数 / 500                 | [0, ∞)              |
| 3   | total_reviews             | 総レビュー数 / 500                 | [0, ∞)              |
| 4   | recent_activity_frequency | 過去 30 日のレビュー数 / 30        | [0, ∞)              |
| 5   | avg_activity_gap          | 平均レビュー間隔（日）/ 60         | [0, 1]              |
| 6   | activity_trend            | 活動増加傾向（カテゴリ化）         | {0, 0.25, 0.5, 1.0} |
| 7   | collaboration_score       | 固定値（未実装）                   | 1.0                 |
| 8   | code_quality_score        | 固定値（未実装）                   | 0.5                 |
| 9   | recent_acceptance_rate    | 固定値（未実装）                   | 0.5                 |
| 10  | review_load               | 最近の負荷 / 平均負荷（正規化）    | [0, 1]              |

**計算タイミング**: 観測期間終了時点（Train: 2023-01-01, Eval: 2024-01-01）

### 4.2 時系列特徴量（97 次元）- Enhanced IRL 独自

#### 4.2.1 受け入れ率シーケンス（30 次元）

過去 30 日間の日次受け入れ率:

```
acceptance_rate[day_i] = (当日のaccept数) / (当日の総レビュー数)
デフォルト値: 0.5（データがない日）
```

#### 4.2.2 レビュー負荷シーケンス（30 次元）

過去 30 日間の日次レビュー数（正規化）:

```
load[day_i] = min((当日のレビュー数) / 10.0, 1.0)
デフォルト値: 0.0（データがない日）
```

#### 4.2.3 応答時間シーケンス（30 次元）

過去 30 日間の日次平均応答時間（正規化）:

```
response_time[day_i] = min((当日の平均応答時間（時間）) / (7*24), 1.0)
デフォルト値: 0.5（データがない日）
```

#### 4.2.4 曜日パターン（7 次元）

曜日ごとの受け入れ率:

```
weekday_pattern[weekday] = (当該曜日のaccept率)
デフォルト値: 0.5（データがない曜日）
```

**計算タイミング**: 観測期間終了時点から過去 30 日間を参照

**NaN 処理**:

- すべての時系列特徴量にデフォルト値を設定
- NaN を含むサンプルはスキップ

### 特徴量総次元数

```
合計 = 状態特徴量（10） + 時系列特徴量（97） = 107次元
```

---

## 5. モデルアーキテクチャ

### 5.1 AttentionIRLNetwork

```python
入力:
  - state: (batch, seq_len=1, 10)
  - temporal: (batch, seq_len=1, 97)

構造:
  1. Input Embedding
     - state_embedding: Linear(10 → 128)
     - temporal_embedding: Linear(97 → 128)
     - concat: (batch, seq_len, 256)

  2. LSTM Encoder
     - 2-layer LSTM
     - hidden_dim: 128
     - bidirectional: False
     - dropout: 0.3

  3. Attention Mechanism
     - Query: LSTM最終hidden state
     - Key/Value: 全LSTM outputs
     - Softmax attention weights

  4. Classification Head
     - LayerNorm(128)
     - Linear(128 → 64)
     - ReLU
     - Dropout(0.3)
     - Linear(64 → 1)
     - Sigmoid

出力:
  - prediction: (batch,) 継続確率 [0, 1]
  - attention_weights: (batch, seq_len) 重み分布
```

### 5.2 ハイパーパラメータ

| パラメータ    | 値      | 説明             |
| ------------- | ------- | ---------------- |
| state_dim     | 10      | 状態特徴量次元   |
| temporal_dim  | 97      | 時系列特徴量次元 |
| hidden_dim    | 128     | LSTM 隠れ層次元  |
| num_layers    | 2       | LSTM 層数        |
| dropout       | 0.3     | ドロップアウト率 |
| learning_rate | 0.001   | 学習率           |
| batch_size    | 16      | バッチサイズ     |
| epochs        | 50      | エポック数       |
| optimizer     | Adam    | 最適化手法       |
| loss          | BCELoss | 損失関数         |

---

## 6. 評価設定

### 6.1 評価指標

- **主指標**: AUC-ROC（クラス不均衡に強い）
- **比較対象**: Random Forest（10 次元状態特徴量のみ使用）

### 6.2 クロスバリデーション

- **方法**: 時系列分割（Train 期間 → Eval 期間）
- **組み合わせ数**: 10 通り（上記表を参照）
- **シード数**: 5（42, 123, 777, 2024, 9999）
- **総実験数**: 10 組み合わせ × 5 シード = 50 実験

### 6.3 統計分析

- シードごとの平均・標準偏差
- 期間組み合わせごとの平均・最大・最小
- RF との差分（絶対値・相対値）
- 勝敗カウント

---

## 7. データ分割

## 7. データ分割

### 7.1 データソース

```
data/review_requests_openstack_multi_5y_detail.csv
総レコード数: 137,632行
期間: 2019-01-01 〜 2024-12-31
```

### 7.2 月次スライディングウィンドウ方式

**重要な変更点**: レビュワー単位の集約から**月次スライディングウィンドウ**に変更

#### Train 期間のサンプリング

```
期間: 2021-01-01 〜 2023-01-01（24ヶ月）

各月について:
  - 観測終了: 月末
  - 予測期間: 月末 + future_start 〜 月末 + future_end
  - データリーク防止: 予測期間がtrain_endを超える場合はクリップまたはスキップ

例: Train予測期間=0-3m, 月=2021-01
  - 観測: 2021-01-01 〜 2021-02-01
  - 予測: 2021-02-01 〜 2021-05-01（OK）
  - サンプル: この月にアクティブだった全レビュワー

例: Train予測期間=9-12m, 月=2022-06
  - 観測: 2021-01-01 〜 2022-07-01
  - 予測: 2023-04-01 〜 2023-07-01（一部がtrain_end超え）
  - 対応: future_endを2023-01-01にクリップ
```

#### Eval 期間のサンプリング

```
期間: 2023-01-01 〜 2024-01-01（12ヶ月）

各月について:
  - 観測終了: 月末
  - 予測期間: 月末 + future_start 〜 月末 + future_end
  - データリーク: 評価用なのでeval_end超えてもOK

例: Eval予測期間=3-6m, 月=2023-06
  - 観測: 2023-01-01 〜 2023-07-01
  - 予測: 2023-10-01 〜 2024-01-01（OK）
  - サンプル: この月にアクティブだった全レビュワー
```

### 7.3 サンプル数の見積もり

**Train 期間**（例: Train=0-3m）:

- 使用可能月数: ~21 ヶ月（最後の 3 ヶ月は future 期間が不足）
- 月あたりレビュワー数: ~150-300 人
- **推定サンプル数: 21 ヶ月 × 200 人 = 約 4,200 サンプル**

**Eval 期間**（例: Eval=0-3m）:

- 使用可能月数: ~12 ヶ月
- 月あたりレビュワー数: ~100-200 人
- **推定サンプル数: 12 ヶ月 × 150 人 = 約 1,800 サンプル**

**注意**:

- 同一レビュワーが複数月に登場するため重複あり
- 実際のサンプル数は予測期間の長さによって変動
- Train 予測期間が長いほど、使用可能月数が減少

### 7.2 Train/Test サンプル数（例: Train=3-6m, Eval=3-6m）

**Train データ**:

- 観測期間のユニークレビュワー: ~650 名
- ラベル分布: 正例（accept 有）~60%, 負例~40%

**Eval データ**:

- 観測期間のユニークレビュワー: ~361 名
- ラベル分布: 正例（accept 有）~55%, 負例~45%

**注意**: レビュワー単位で集約（同一レビュワーは 1 サンプル）

---

## 8. 実装の重要ポイント

### 8.1 時系列順序の保証

```python
# 制約条件
if eval_future_start >= train_future_start:
    # 有効な組み合わせ
    run_experiment(train_future, eval_future)
```

### 8.2 データリーク防止

- 観測期間と予測期間を厳密に分離
- Train: 2021-01-01〜2023-01-01 の情報のみ使用
- Eval: 2023-01-01〜2024-01-01 の情報のみ使用
- 予測期間のデータは特徴量計算に**絶対に使用しない**

### 8.3 ラベル計算の正確性

```python
# Train用ラベル
future_start_train = train_end + timedelta(days=train_future_start * 30)
future_end_train = train_end + timedelta(days=train_future_end * 30)
label_train = has_accept_in_period(reviewer, future_start_train, future_end_train)

# Eval用ラベル（独立して計算）
future_start_eval = eval_end + timedelta(days=eval_future_start * 30)
future_end_eval = eval_end + timedelta(days=eval_future_end * 30)
label_eval = has_accept_in_period(reviewer, future_start_eval, future_end_eval)
```

---

## 9. 実験結果（速報）

### 9.1 修正前の問題（バグ#1）

**症状**: 予測期間が変わっても AUC が一定
**原因**: Train/Eval 両方で同じ予測期間を使用していた

```python
# ❌ バグのあるコード
all_data[key] = prepare_data(df, ..., eval_s, eval_e)  # Trainも同じ
```

### 9.2 修正後（バグ#1 対応）

**修正内容**: Train/Eval で個別の予測期間を指定

```python
# ✅ 修正後
all_data[key] = prepare_data(
    df, ...,
    train_s, train_e,  # Train用
    eval_s, eval_e     # Eval用
)
```

### 9.3 修正前の問題（バグ#2 & #3）

**症状 1**: サンプル数が少なすぎる（Train: 650, Eval: 361）
**原因 1**: レビュワー単位で 1 サンプルのみ（月次集約なし）

**症状 2**: Train のラベル計算が Eval 観測期間を参照
**原因 2**: Train 予測期間が train_end を超えてもクリップしていなかった

**具体例**:

```
Train期間: 2021-01-01 〜 2023-01-01
Train予測期間（9-12m）: 2023-10-01 〜 2024-01-01
                        ↑
                  Eval観測期間: 2023-01-01 〜 2024-01-01
                  → 重複している！（データリーク）
```

### 9.4 修正後（バグ#2 & #3 対応）

**修正内容 1**: 月次スライディングウィンドウ方式に変更

```python
# ✅ 月次でサンプリング
train_months = pd.date_range(start=train_start_dt, end=train_end_dt, freq='MS')

for month_start in train_months[:-1]:
    month_end = month_start + pd.DateOffset(months=1)
    # 各月でレビュワーごとにサンプル作成
    # → Train期間24ヶ月 × ~200レビュワー = 約4,800サンプル
```

**修正内容 2**: データリーク防止のためのクリップ処理

```python
# ✅ train_endを超えないようにクリップ
if future_start >= train_end_dt:
    continue  # この月は使用しない

if future_end > train_end_dt:
    future_end = train_end_dt  # クリップ
```

**効果**:

- サンプル数: Train ~650 → ~4,800（7 倍増加）
- データリーク: あり → なし
- 時系列情報: なし → あり（月次で異なる文脈）

---

## 10. 次のステップ

### 10.1 再実行

- [x] バグ修正完了
- [ ] 全 5 シード × 10 組み合わせの再実行
- [ ] 結果の再分析

### 10.2 期待される変化

- 予測期間ごとに AUC が変動する
- 短期予測（0-3m）と長期予測（9-12m）で性能差が出る
- Train 期間と Eval 期間の組み合わせによる傾向が明確になる

### 10.3 分析項目

- どの予測期間が最も予測しやすいか？
- Train 期間と Eval 期間の最適な組み合わせは？
- RF に勝てる期間はあるか？
- 時系列特徴量の効果はどの期間で顕著か？

---

## 参考資料

### データスキーマ

```csv
reviewer_email, request_time, label, project, ...
```

### 使用ライブラリ

- PyTorch 2.8.0
- pandas, numpy
- scikit-learn（評価指標のみ）
- Python 3.13.1

---

**最終更新**: 2025 年 11 月 8 日
**実験者**: Enhanced IRL Team
**ステータス**: ⚠️ バグ修正完了、再実行待ち
