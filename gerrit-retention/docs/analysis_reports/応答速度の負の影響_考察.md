# 応答速度の負の影響: 考察

## 📅 作成日
2025-10-30

## 🤔 疑問

> 応答速度は負のなんですね、以外

特徴量重要度分析で**応答速度が負の影響**を持つことが判明（重要度: -0.006121）

## 📊 データの実態

### response_time の分布

| データセット | 欠損率 | 平均レスポンス時間 | 中央値 |
|-------------|--------|-------------------|--------|
| multi_5y_detail.csv | 91.5% | 2.62日 | 1.00日 |
| pilot_w14_v4.csv | 10.5% | 2.13日 | 0.00日 |

### 実際のデータ分布（multi_5y_detail.csv）

```
全データ: 137,632件
- 欠損: 125,996件 (91.5%) ← これが問題
- 0日: 5,414件 (3.9%)
- 1-3日: 2,790件 (2.0%)
- 4-7日: 2,018件 (1.5%)
- 8-14日: 1,414件 (1.0%)
```

**問題**: **91.5%のデータが欠損** → デフォルト値 0.0 が使われる

## 🔍 なぜ負の影響なのか？

### 1. データの問題

#### 欠損値の扱い

```python
def _calculate_response_time(self, activity: Dict[str, Any]) -> float:
    """レスポンス時間を計算（日数）"""
    
    # レビューリクエストの作成日時と応答日時の差を計算
    request_time = activity.get('request_time')
    response_time = activity.get('timestamp')
    
    if request_time and response_time:
        # 計算可能な場合
        days_diff = (response_dt - request_dt).days
        return max(0.0, days_diff)
    
    # デフォルト値（データがない場合）
    return 0.0  # ← これが91.5%のデータで使われる
```

**問題**: 欠損値が0日として扱われる

#### 特徴量への変換

```python
def action_to_tensor(self, action: DeveloperAction) -> torch.Tensor:
    """行動をテンソルに変換（4次元版）"""
    
    # レスポンス時間を「素早さ」に変換（0-1の範囲に正規化）
    # response_time が短い（素早い）ほど値が大きくなる
    response_speed = 1.0 / (1.0 + action.response_time / 3.0)
    
    features = [
        min(action.intensity, 1.0),
        min(action.collaboration, 1.0),
        min(response_speed, 1.0),  # ← ここで使用
        min(action.review_size, 1.0)
    ]
```

**変換式**:
- response_time = 0日 → response_speed = 1.0 / (1.0 + 0/3.0) = **1.0**（最速）
- response_time = 3日 → response_speed = 1.0 / (1.0 + 3/3.0) = **0.5**
- response_time = 6日 → response_speed = 1.0 / (1.0 + 6/3.0) = **0.33**

### 2. なぜ負の影響なのか？

#### 仮説1: 欠損データの偏り

**前提**:
- 欠損データは「非アクティブなレビュアー」に多い
- これらのレビュアーは継続しない傾向がある

**推論**:
```
response_time = 0（欠損） → response_speed = 1.0（最高速度）
↓
このサンプルは非アクティブ
↓
継続しない傾向がある
↓
「高速な応答 = 継続しない」
↓
負の相関
```

#### 仮説2: 実際の関係性

**逆の因果関係の可能性**:

```
応答が速すぎる → 継続しない？
↓
考えられる理由:
1. 突発的に参加したレビュアー
2. 短期的な関与
3. 継続的な関与ではない
```

### 3. データの実際の分布

#### 有効データ（8.5%）だけを見ると

```python
response_latency_days の統計:
  平均: 2.62 日
  中央値: 1.00 日
  最小値: 0.00 日
  最大値: 13.00 日
```

- 実際のレスポンス時間は**1-3日**が多い
- これらのサンプルは**アクティブなレビュアー**
- 継続する傾向がある

#### 欠損データ（91.5%）の扱い

```python
response_time = 0（デフォルト）
↓
response_speed = 1.0（最速）
↓
これらのサンプルは非アクティブ
↓
継続しない傾向
```

**結果**: 最速の応答速度を持つサンプル = 継続しない傾向

---

## 💡 解決策

### 案1: 欠損値の適切な扱い

```python
def _calculate_response_time(self, activity: Dict[str, Any]) -> float:
    """レスポンス時間を計算（日数）"""
    
    request_time = activity.get('request_time')
    response_time = activity.get('timestamp')
    
    if request_time and response_time:
        days_diff = (response_dt - request_dt).days
        return max(0.0, days_diff)
    
    # 欠損値の場合は平均値を使用
    return 3.0  # 平均レスポンス時間（約2.6日）を四捨五入
```

### 案2: 欠損フラグの追加

```python
@dataclass
class DeveloperAction:
    action_type: str
    intensity: float
    collaboration: float
    response_time: float
    review_size: float
    has_response_time: bool  # ← NEW: 欠損フラグ
    timestamp: datetime
```

### 案3: 応答速度の除外

```python
# 応答速度を除外して3次元特徴量に
features = [
    min(action.intensity, 1.0),
    min(action.collaboration, 1.0),
    # min(response_speed, 1.0),  # 除外
    min(action.review_size, 1.0)
]
```

---

## 🎯 推奨される対応

### すぐに対応すべきこと

1. **データの確認**
   - 欠損値のパターンを分析
   - 欠損が非アクティブレビュアーに偏っていないか

2. **欠損値の扱いを改善**
   - デフォルト値を0ではなく平均値に
   - 欠損フラグの追加

3. **特徴量の見直し**
   - 欠損が多い特徴量は除外を検討
   - 代替特徴量の探索

### 長期的な対応

1. **データ収集の改善**
   - response_time の収集率向上
   - データ品質の監視

2. **モデルの改善**
   - 欠損値への対応を強化
   - より頑健な特徴量設計

---

## 📊 影響度

### 現状の影響

- **重要度: -0.006121**
- 他の特徴量と比較して**中程度の影響**
- 動作自体には大きな問題はない

### 改善による期待効果

- **AUC-PRの向上**
- **より正確な予測**
- **特徴量の解釈性向上**

---

## 📝 まとめ

### 原因

1. **91.5%のデータが欠損**
2. **欠損値が0日として扱われる**
3. **欠損データが非アクティブレビュアーに偏っている**
4. **高速な応答速度 = 継続しない**という偽の相関

### 解決策

1. **欠損値の扱いを改善**（デフォルト値を平均に）
2. **欠損フラグの追加**（情報の明示）
3. **応答速度の除外を検討**（データ不足）

### 優先度

- **中程度**
- 現状でも動作しているが、改善の余地あり

---

作成日: 2025-10-30

