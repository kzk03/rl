# スライディングウィンドウ評価ガイド

## 📋 概要

履歴窓 × 将来窓の**全組み合わせを自動評価**して、最適な設定を発見します。

---

## 🎯 目的

### 研究課題（RQ1）

**「最適な履歴窓と将来窓の組み合わせは何か？」**

### 評価する組み合わせ

```python
履歴窓: [3ヶ月, 6ヶ月, 9ヶ月, 12ヶ月]
将来窓: [0-1m, 1-3m, 3-6m, 6-12m]

総実験数: 4 × 4 = 16 組み合わせ
```

---

## 🚀 クイックスタート

### 基本的な実行

```bash
# デフォルト設定で実行（16組み合わせ）
./scripts/training/irl/run_sliding_window_evaluation.sh
```

### カスタム設定

```bash
uv run python scripts/training/irl/train_irl_sliding_window_evaluation.py \
  --reviews data/review_requests_openstack_multi_5y_detail.csv \
  --train-start 2019-01-01 \
  --train-end 2020-01-01 \
  --eval-start 2020-01-01 \
  --eval-end 2021-01-01 \
  --history-windows 3 6 9 12 \
  --future-windows 0-1 1-3 3-6 6-12 \
  --epochs 30 \
  --sequence \
  --output outputs/sliding_window_evaluation
```

---

## 📊 出力結果

### ディレクトリ構造

```
outputs/sliding_window_evaluation/
├── models/                           # 訓練済みモデル（16個）
│   ├── irl_h3m_f0_1m.pth
│   ├── irl_h3m_f1_3m.pth
│   └── ...
├── all_results.json                  # 全結果（JSON）
├── auc_roc_matrix.csv                # AUC-ROC行列
├── auc_pr_matrix.csv                 # AUC-PR行列
├── f1_matrix.csv                     # F1行列
├── precision_matrix.csv              # Precision行列
├── recall_matrix.csv                 # Recall行列
└── sliding_window_heatmaps.png       # ヒートマップ可視化
```

---

## 📈 結果の見方

### 1. AUC-ROC 行列（例）

```
               0-1m    1-3m    3-6m   6-12m
3m            0.731   0.682   0.654   0.612
6m            0.842   0.802   0.757   0.718
9m            0.853   0.750   0.727   0.762
12m           0.777   0.855*  0.799   0.791

最良: 0.855 (履歴=12m, 将来=1-3m)
```

**解釈:**

- **12 ヶ月の履歴 × 1-3 ヶ月の将来窓** が最高性能
- 短い履歴（3m）では性能が低い
- 長期予測（6-12m）は難しい傾向

---

### 2. ヒートマップ

<img src="../importants/example_heatmap.png" width="800">

**ヒートマップの見方:**

- 🟢 緑: 高性能
- 🟡 黄: 中性能
- 🔴 赤: 低性能

**パターン分析:**

- 対角線が強い → 履歴と将来窓のバランスが重要
- 上部が強い → 長い履歴が有効
- 左部が強い → 短期予測が容易

---

### 3. all_results.json

```json
[
  {
    "history_window": 6,
    "future_window_start": 1,
    "future_window_end": 3,
    "future_window_label": "1-3m",
    "train_samples": 5432,
    "eval_samples": 1234,
    "metrics": {
      "auc_roc": 0.802,
      "auc_pr": 0.756,
      "f1": 0.687,
      "precision": 0.721,
      "recall": 0.656,
      "test_samples": 1234,
      "positive_samples": 189,
      "positive_rate": 0.153
    },
    "model_path": "outputs/.../irl_h6m_f1_3m.pth"
  },
  ...
]
```

---

## 🔬 実験パターン

### パターン 1: デフォルト（推奨）

```bash
--history-windows 3 6 9 12
--future-windows 0-1 1-3 3-6 6-12
```

**目的:** 広範囲を網羅的に評価

---

### パターン 2: 細かい粒度

```bash
--history-windows 3 4 5 6 7 8 9 10 11 12
--future-windows 0-1 1-2 2-3 3-4 4-5 5-6
```

**目的:** 最適点を精密に特定  
**注意:** 実験数が多い（10 × 6 = 60）

---

### パターン 3: 短期集中

```bash
--history-windows 1 2 3
--future-windows 0-1 1-2 2-3
```

**目的:** 短期予測に特化  
**用途:** リアルタイム介入システム

---

### パターン 4: 長期集中

```bash
--history-windows 6 12 18 24
--future-windows 3-6 6-12 12-18 18-24
```

**目的:** 長期的な定着予測  
**用途:** 戦略的な人材育成

---

## 📊 論文での活用

### Table: 履歴窓 × 将来窓の組み合わせ評価

| 履歴窓 | 0-1m  | 1-3m      | 3-6m  | 6-12m |
| ------ | ----- | --------- | ----- | ----- |
| 3m     | 0.731 | 0.682     | 0.654 | 0.612 |
| 6m     | 0.842 | 0.802     | 0.757 | 0.718 |
| 9m     | 0.853 | 0.750     | 0.727 | 0.762 |
| 12m    | 0.777 | **0.855** | 0.799 | 0.791 |

_表: AUC-ROC スコア。太字は最良値。_

---

### Figure: ヒートマップ

<img src="../outputs/sliding_window_evaluation/sliding_window_heatmaps.png">

_図: 履歴窓と将来窓の組み合わせによる性能比較。緑は高性能、赤は低性能を示す。_

---

### 発見事項の記述例

**RQ1: 最適な履歴窓と将来窓の組み合わせは？**

> スライディングウィンドウ評価により、16 組み合わせを体系的に比較した結果、**12 ヶ月の履歴と 1-3 ヶ月の将来窓**が最高の AUC-ROC（0.855）を達成した。この結果は、中期的な予測（1-3 ヶ月後）には長期的な履歴（12 ヶ月）が有効であることを示している。
>
> 一方、短期予測（0-1 ヶ月後）では履歴が長すぎると性能が低下する傾向が見られた（12m 履歴: 0.777 vs 9m 履歴: 0.853）。これは、短期的な変化を捉えるには適度な履歴長が重要であることを示唆している。

---

## 🎓 統計分析

### 分散分析（ANOVA）

```python
# 履歴窓の効果
history_effect = anova(auc_roc ~ history_window)

# 将来窓の効果
future_effect = anova(auc_roc ~ future_window)

# 交互作用
interaction = anova(auc_roc ~ history_window * future_window)
```

**質問:**

- 履歴窓の違いは有意か？
- 将来窓の違いは有意か？
- 交互作用はあるか？

---

### ポストホック検定

```python
# 多重比較補正（Bonferroni）
pairwise_comparison(history_windows, method='bonferroni')
```

**目的:** どの組み合わせ間に有意差があるか特定

---

## ⚙️ パラメータ詳細

### 必須パラメータ

| パラメータ      | 説明             |
| --------------- | ---------------- |
| `--reviews`     | レビューログ CSV |
| `--train-start` | 訓練期間の開始日 |
| `--train-end`   | 訓練期間の終了日 |

### ウィンドウ設定

| パラメータ          | デフォルト         | 説明                        |
| ------------------- | ------------------ | --------------------------- |
| `--history-windows` | `3 6 9 12`         | 履歴窓のリスト（ヶ月）      |
| `--future-windows`  | `0-1 1-3 3-6 6-12` | 将来窓のリスト（開始-終了） |

### 訓練設定

| パラメータ   | デフォルト | 説明                         |
| ------------ | ---------- | ---------------------------- |
| `--epochs`   | `30`       | 訓練エポック数               |
| `--sequence` | `False`    | 時系列モード（LSTM）を有効化 |
| `--seq-len`  | `15`       | シーケンス長                 |

---

## 🐛 トラブルシューティング

### 実験時間が長すぎる

**解決策 1: エポック数を減らす**

```bash
--epochs 10  # デフォルト: 30
```

**解決策 2: 組み合わせを減らす**

```bash
--history-windows 6 12  # 2つのみ
--future-windows 0-1 1-3  # 2つのみ
# 総実験数: 2 × 2 = 4
```

---

### メモリ不足

**解決策: シーケンス長を短くする**

```bash
--seq-len 10  # デフォルト: 15
```

---

### 一部の組み合わせでデータなし

**原因:** 履歴窓や将来窓が学習期間を超えている

**解決策:** 学習期間を延長

```bash
--train-start 2018-01-01  # より早い開始日
--train-end 2020-01-01
```

---

## 📚 関連ドキュメント

- **設計書**: `docs/将来的な比較実験の設計.md`
- **基本訓練**: `scripts/training/irl/README_WITHIN_TRAINING_PERIOD.md`
- **詳細設計**: `docs/IRL最終設計_学習期間内完結版.md`

---

## 🎉 次のステップ

### Phase 1 完了後

✅ スライディングウィンドウ評価  
→ **Phase 2**: 時間的汎化性能評価  
→ **Phase 3**: ローリングウィンドウ評価  
→ **Phase 4**: 層別分析

### 論文執筆

1. 実験を実行
2. ヒートマップを分析
3. 最適な組み合わせを発見
4. 統計的検定を実施
5. RQ1 に答える

---

**作成日:** 2025-10-21  
**ステータス:** 実装済み
