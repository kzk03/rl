# 再訓練結果: デフォルト値を 3 日に変更

## 📅 作成日

2025-10-30

## 🎯 変更内容

### 修正

```python
# 変更前
def _calculate_response_time(self, activity: Dict[str, Any]) -> float:
    # ...
    return 0.0  # デフォルト値

# 変更後
def _calculate_response_time(self, activity: Dict[str, Any]) -> float:
    # ...
    return 3.0  # 平均レスポンス時間（約2.6日を四捨五入）
```

### 理由

- 欠損値が 0 日として扱われると、response_speed が 1.0（最速）になる
- これが非アクティブなレビュアーに偏っていた
- 平均レスポンス時間（3 日）を使用することで偏りを緩和

---

## 📊 結果

### メトリクス

| 期間  | AUC-PR | Precision | Recall | F1-score |
| ----- | ------ | --------- | ------ | -------- |
| 0-3m  | 0.611  | 0.577     | 0.714  | 0.638    |
| 3-6m  | 0.816  | 0.682     | 0.833  | 0.750    |
| 6-9m  | 0.788  | 0.818     | 0.692  | 0.750    |
| 9-12m | 0.658  | 0.556     | 0.938  | 0.698    |

**平均 AUC-PR: 0.718**

### 比較

| 項目             | 変更前（デフォルト 0 日） | 変更後（デフォルト 3 日） |
| ---------------- | ------------------------- | ------------------------- |
| 平均 AUC-PR      | 0.718                     | **0.718**                 |
| 応答速度の重要度 | -0.006121                 | **-0.006121**             |

**結果**: **変更なし**

---

## 🔍 考察

### なぜ結果が変わらなかったのか？

#### 1. データの偏りは変わらない

```python
# 変換式
response_time = 3日 → response_speed = 1.0 / (1.0 + 3/3.0) = 0.5
response_time = 0日（欠損） → response_speed = 1.0 / (1.0 + 0/3.0) = 1.0
```

**変更前**:

- response_time = 0 日 → response_speed = 1.0
- これらのサンプルは非アクティブ

**変更後**:

- response_time = 3 日 → response_speed = 0.5
- 欠損データが平均的な応答速度を持つ

**しかし**: データの質が改善されたわけではない

- 欠損データは依然として「非アクティブなレビュアー」に多い
- デフォルト値を変更しても、根本的な問題は解決していない

#### 2. 重要度が変わらない理由

**応答速度の重要度: -0.006121**

これは「応答が速いほど継続しない」という関係を示している。

**考えられる解釈**:

1. 突発的に参加したレビュアー
2. 短期的な関与
3. 継続的な関与ではない

これらのレビュアーは応答が速いが、継続しない傾向がある。

---

## 💡 結論

### デフォルト値の変更による影響

- **メトリクス**: 変化なし（0.718 → 0.718）
- **重要度**: 変化なし（-0.006121 → -0.006121）

### 応答速度の解釈

負の重要度は以下の可能性を示す:

1. **逆の因果関係**

   - 応答が速い = 突発的参加 = 継続しない

2. **データの偏り**

   - 欠損データが非アクティブに偏っている
   - デフォルト値を変更しても根本的な問題は残る

3. **実際の関係性**
   - 応答速度そのものが継続予測に寄与していない
   - 他の要因（協力度、活動量）の方が重要

---

## 🎯 推奨される対応

### 1. 応答速度の除外を検討

```python
# 4次元 → 3次元
features = [
    min(action.intensity, 1.0),        # 強度（変更ファイル数、0-1）
    min(action.collaboration, 1.0),    # 協力度（0-1）
    # min(response_speed, 1.0),        # 応答速度を除外
    min(action.review_size, 1.0)       # レビュー規模（変更行数、0-1）
]
```

### 2. 欠損値の扱いを改善

#### 案 A: 欠損フラグの追加

```python
@dataclass
class DeveloperAction:
    action_type: str
    intensity: float
    collaboration: float
    response_time: float
    review_size: float
    has_response_time: bool  # ← NEW
    timestamp: datetime
```

#### 案 B: 条件付き計算

```python
def action_to_tensor(self, action: DeveloperAction) -> torch.Tensor:
    """行動をテンソルに変換（4次元版）"""

    # 応答速度は条件付きで使用
    if action.has_response_time:
        response_speed = 1.0 / (1.0 + action.response_time / 3.0)
    else:
        response_speed = 0.5  # 中立な値

    features = [
        min(action.intensity, 1.0),
        min(action.collaboration, 1.0),
        min(response_speed, 1.0),
        min(action.review_size, 1.0)
    ]

    return torch.tensor(features, dtype=torch.float32, device=self.device)
```

---

## 📊 今後の実験

### 実験候補

1. **応答速度を除外**して再訓練
   - 期待: AUC-PR の向上
2. **欠損フラグを追加**して再訓練

   - 期待: より正確な予測

3. **現状のまま使用**
   - 現状でも AUC-PR 0.718 と十分に高い
   - 応答速度の負の影響も限定的（重要度-0.006）

---

## 📝 まとめ

### 結果

- デフォルト値を 3 日に変更しても結果は変わらない
- 応答速度の負の影響はデータの偏りではなく、実際の関係性の可能性

### 推奨

- 現状のまま使用するか、応答速度を除外することを検討
- 欠損データの問題は残るが、AUC-PR 0.718 という高い性能を達成

---

作成日: 2025-10-30
